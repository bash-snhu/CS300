# CS300
CS300 Course Repository

## What was the problem you were solving in the projects for this course?

The problem presented in the projects for this course was the selection of data structures based on the application or problem to be solved. We were given a specific scenario with specific data and needs, and we were then tasked to find an appropriate solution to fit that application.

## How did you approach the problem? Consider why data structures are important to understand.

I approached the problem by first trying to understand the requirements of the solution to the best of my ability. The client needed to read data into a data structure from a source that was mostly sorted, which would then need to be fully sorted, with no insertions after the fact. Additionally, the ID they would be sorted by had similar endings, which would mean high collisions for a hash table. I was worried using a vector structure would be seen as taking the easy way out, but I genuinely believe it is the most straightforward and non-overcomplicated solution for the given scenario.

## How did you overcome any roadblocks you encountered while going through the activities or project?

I had difficulty with some activities, trying to incorporate each data structure into the bid and node classes used in the activities. I felt I understood the way it was presented in zylabs, but translating into a mostly written program was sometimes difficult. I think that is mostly because I haven't used C++ OOP a lot, but I think that will get better with more experience.

## How has your work on this project expanded your approach to designing software and developing programs?

I've learned from this course that the simplest route isn't always the best and that there are a lot of data structure options out there that aren't baked into the popular programming languages. It's very important, especially when dealing with a lot of data, to choose a data structure that is appropriate and efficient in its application.

## How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

In working with modifying pre-existing code, I've learned how important it is to have good communication and organization when developing code that others will work on at some point. Also, that implementing a complicated data structure is fine as long as using it is clear and easy when writing other parts of the program that integrate with it.

